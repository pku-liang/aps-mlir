//===- BlockHandler.cpp - Unified Block Handler Implementation ------------===//
//
// This file implements the unified block handler with producer-responsible
// FIFO coordination for all control flow structures
//
//===----------------------------------------------------------------------===//

#include "APS/BlockHandler.h"
#include "APS/BBHandler.h"
#include "APS/LoopHandler.h"
#include "APS/APSOps.h"
#include "TOR/TOR.h"
#include "circt/Dialect/Cmt2/ECMT2/SignalHelpers.h"
#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include "mlir/IR/Block.h"
#include "mlir/IR/Operation.h"
#include "mlir/IR/Value.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/LogicalResult.h"
#include "llvm/Support/raw_ostream.h"

namespace mlir {

using namespace mlir;
using namespace mlir::tor;
using namespace circt::cmt2::ecmt2;
using namespace circt::cmt2::ecmt2::stl;
using namespace circt::firrtl;

//===----------------------------------------------------------------------===//
// BlockHandler Implementation
//===----------------------------------------------------------------------===//

BlockHandler::BlockHandler(APSToCMT2GenPass *pass, Module *mainModule, tor::FuncOp funcOp,
                          Instance *poolInstance, Instance *roccInstance,
                          Instance *hellaMemInstance, InterfaceDecl *dmaItfc,
                          Circuit &circuit, Clock mainClk, Reset mainRst,
                          unsigned long opcode, Instance *regRdInstance,
                          Instance *inputTokenFIFO, Instance *outputTokenFIFO,
                          llvm::DenseMap<Value, Instance*> &input_fifos,
                          llvm::DenseMap<Value, llvm::SmallVector<std::pair<BlockInfo*, Instance*>, 4>> &output_fifos,
                          const std::string &namePrefix)
    : pass(pass), mainModule(mainModule), funcOp(funcOp), poolInstance(poolInstance),
      roccInstance(roccInstance), hellaMemInstance(hellaMemInstance), regRdInstance(regRdInstance),
      dmaItfc(dmaItfc), circuit(circuit), mainClk(mainClk), mainRst(mainRst), opcode(opcode),
      namePrefix(namePrefix.empty() ? "inst" + (std::ostringstream() << std::hex << std::setw(4) << std::setfill('0') << opcode).str() + "_" : namePrefix),
      inputTokenFIFO(inputTokenFIFO), outputTokenFIFO(outputTokenFIFO), input_fifos(input_fifos),
      output_fifos(output_fifos) {
}

LogicalResult BlockHandler::processFunctionAsBlocks() {
  llvm::dbgs() << "[BlockHandler] Processing function as unified blocks\n";

  // Phase 1: Block Analysis
  if (failed(identifyBlocksByFuncOp()))
    return failure();

  if (blocks.empty()) {
    llvm::dbgs() << "[BlockHandler] No blocks found in function\n";
    return success();
  }

  if (failed(analyzeCrossBlockDataflow()))
    return failure();

  // Phase 2: FIFO Infrastructure
  // Create cross-block value FIFOs (data communication)
  if (failed(createProducerFIFOs()))
    return failure();

  // Create intra-block coordination FIFOs (slot-to-slot within blocks)
  if (failed(createBlockTokenFIFOs()))
    return failure();

  // Phase 2.5: Input Distribution Analysis and Infrastructure
  // Analyze if sub-blocks need input distribution (1-to-N fanout)
  if (failed(analyzeInputDistributionNeeds()))
    return failure();

  // Create input distribution FIFOs if needed
  if (failed(createInputDistributionInfrastructure()))
    return failure();

  // Generate input distribution rule if needed
  if (failed(generateInputDistributionRule()))
    return failure();

  // Phase 3: Block Processing (delegated to handlers)
  // Note: BlockHandler no longer generates rules directly
  // Rules are generated by BBHandler and LoopHandler
  if (failed(processAllBlocks()))
    return failure();

  return success();
}

LogicalResult BlockHandler::identifyBlocksByLoop(tor::ForOp loopOp) {
  llvm::dbgs() << "[BlockHandler] Identifying blocks in loop body\n";

  unsigned blockId = 0;

  // Get the loop body block from the tor::ForOp
  Block *loopBody = loopOp.getBody();
  if (!loopBody) {
    llvm::dbgs() << "[BlockHandler] Loop has no body block\n";
    return success();
  }

  // Debug: print loop body structure
  llvm::dbgs() << "[BlockHandler] Loop body has " << loopBody->getNumArguments()
               << " arguments and " << loopBody->getOperations().size() << " operations\n";

  // Process the loop body block specifically
  // This will segment the loop body based on control flow operations
  if (failed(segmentBlockIntoBlocks(loopBody, blockId))) {
    return failure();
  }

  llvm::dbgs() << "[BlockHandler] Identified " << blocks.size() << " blocks in loop body\n";
  return success();
}

LogicalResult BlockHandler::processLoopBodyAsBlocks(tor::ForOp loopOp) {
  llvm::dbgs() << "[BlockHandler] Processing loop body as unified blocks\n";

  // Phase 1: Block Analysis
  if (failed(identifyBlocksByLoop(loopOp)))
    return failure();

  if (blocks.empty()) {
    llvm::dbgs() << "[BlockHandler] No blocks found in function\n";
    return success();
  }

  if (failed(analyzeCrossBlockDataflow()))
    return failure();

  // Phase 2: FIFO Infrastructure
  // Create cross-block value FIFOs (data communication)
  if (failed(createProducerFIFOs()))
    return failure();

  // Create intra-block coordination FIFOs (slot-to-slot within blocks)
  if (failed(createBlockTokenFIFOs()))
    return failure();

  // Phase 2.5: Input Distribution Analysis and Infrastructure
  // Analyze if sub-blocks need input distribution (1-to-N fanout)
  if (failed(analyzeInputDistributionNeeds()))
    return failure();

  // Create input distribution FIFOs if needed
  if (failed(createInputDistributionInfrastructure()))
    return failure();

  // Generate input distribution rule if needed
  if (failed(generateInputDistributionRule()))
    return failure();

  // Phase 3: Block Processing (delegated to handlers)
  // Note: BlockHandler no longer generates rules directly
  // Rules are generated by BBHandler and LoopHandler
  if (failed(processAllBlocks()))
    return failure();

  return success();
}

LogicalResult BlockHandler::createBlockTokenFIFOs() {
  // Create token FIFOs for cross-block coordination following Blockgen.md
  // token_fifo_b{i}_b{i+1} as specified in the documentation
  // Note: First block's input token FIFO should be provided externally

  auto &builder = mainModule->getBuilder();
  auto savedIP = builder.saveInsertionPoint();

  unifiedTokenFIFOs.clear();

  for (size_t i = 0; i + 1 < blocks.size(); ++i) {
    BlockInfo &currentBlock = blocks[i];
    BlockInfo &nextBlock = blocks[i + 1];

    auto *tokenMod = STLLibrary::createFIFO1PushModule(1, circuit);
    builder.restoreInsertionPoint(savedIP);

    // Follow Blockgen.md naming: {prefix}token_fifo_b{i}_b{i+1}
    std::string tokenName = namePrefix + "token_fifo_b" + std::to_string(currentBlock.blockId) +
                           "_b" + std::to_string(nextBlock.blockId);
    auto *tokenFIFO = mainModule->addInstance(tokenName, tokenMod,
                                              {mainClk.getValue(), mainRst.getValue()});

    unifiedTokenFIFOs[std::make_pair(currentBlock.blockId, nextBlock.blockId)] = tokenFIFO;

    // Set up unified token system using new naming convention
    currentBlock.output_token_fifo = tokenFIFO;
    nextBlock.input_token_fifo = tokenFIFO;
  }

  blocks[0].input_token_fifo = inputTokenFIFO; // the whole block's
  blocks[blocks.size() - 1].output_token_fifo = outputTokenFIFO; // same

  return success();
}

LogicalResult BlockHandler::identifyBlocksByFuncOp() {
  llvm::dbgs() << "[BlockHandler] Identifying blocks in function\n";

  unsigned blockId = 0;

  // Debug: print function structure
  llvm::dbgs() << "[BlockHandler] Function " << funcOp.getName() << " has "
               << funcOp.getBody().getBlocks().size() << " top-level blocks\n";

  // Process each basic block in the function
  for (Block &mlirBlock : funcOp.getBody().getBlocks()) {
    llvm::dbgs() << "[BlockHandler] Processing top-level block with " << mlirBlock.getNumArguments()
                 << " arguments and " << mlirBlock.getOperations().size() << " operations\n";
    // Now properly segment the block based on control flow operations
    if (failed(segmentBlockIntoBlocks(&mlirBlock, blockId))) {
      return failure();
    }
  }

  llvm::dbgs() << "[BlockHandler] Identified " << blocks.size() << " blocks\n";
  return success();
}

LogicalResult BlockHandler::analyzeCrossBlockDataflow() {
  // Analyze cross-block dataflow following Blockgen.md requirements
  // Create mapping: crossBlockEdge: (op, def_block, use_block)
  // PANIC: Ensure data integrity during analysis

  crossBlockFlows.clear();

  llvm::errs() << "\n========== analyzeCrossBlockDataflow ==========\n";

  for (BlockInfo &producerBlock : blocks) {
    // PANIC: Ensure producer block is valid
    if (producerBlock.blockId >= blocks.size()) {
      llvm::report_fatal_error("Invalid producer block ID during dataflow analysis");
    }

    llvm::errs() << "\n--- Block " << producerBlock.blockId << " (" << producerBlock.blockName
                 << ") has " << producerBlock.producedValues.size() << " produced values ---\n";

    for (Value producedValue : producerBlock.producedValues) {
      if (auto *defOp = producedValue.getDefiningOp()) {
        llvm::errs() << "  Produced value from op: " << defOp->getName() << "\n";
      } else {
        llvm::errs() << "  Produced value (block arg)\n";
      }

      // PANIC: Ensure value is valid
      if (!producedValue) {
        llvm::report_fatal_error("Null value in producer block");
      }

      // Skip virtual values that don't need FIFOs
      if (isVirtualValue(producedValue)) {
        llvm::errs() << "    Skipping virtual value\n";
        continue;
      }

      auto consumers = findValueConsumers(producedValue);

      for (BlockInfo *consumerBlock : consumers) {
        // PANIC: Ensure consumer block is valid
        if (!consumerBlock) {
          llvm::report_fatal_error("Null consumer block during dataflow analysis");
        }

        if (consumerBlock != &producerBlock) {
          // PANIC: Ensure consumer block ID is valid
          if (consumerBlock->blockId >= blocks.size()) {
            llvm::report_fatal_error("Invalid consumer block ID during dataflow analysis");
          }

          CrossBlockValueFlow flow;
          flow.value = producedValue;
          flow.producer_block = &producerBlock;
          flow.consumer_block = consumerBlock;
          flow.fifo = nullptr; // Will be set during FIFO creation

          crossBlockFlows.push_back(flow);
        }
      }
    }
  }

  return success();
}

BlockType BlockHandler::determineBlockType(Block* block) {
  // Check for loop operations
  if (containsLoop(block)) {
    return BlockType::LOOP_HEADER;
  }

  // Check for conditional operations
  if (containsConditional(block)) {
    return BlockType::CONDITIONAL_THEN; // Will be refined later
  }

  return BlockType::REGULAR;
}

bool BlockHandler::containsLoop(Block* block) {
  return block->walk([&](tor::ForOp forOp) {
    return WalkResult::interrupt(); // Found loop
  }).wasInterrupted();
}

bool BlockHandler::containsConditional(Block* block) {
  return block->walk([&](tor::IfOp ifOp) {
    return WalkResult::interrupt(); // Found conditional
  }).wasInterrupted();
}

LogicalResult BlockHandler::segmentBlockIntoBlocks(Block *mlirBlock, unsigned &blockId) {
  // Segment block into control flow blocks following Blockgen.md requirements
  // Operations are grouped into blocks based on control flow boundaries
  llvm::SmallVector<llvm::SmallVector<Operation*, 8>> blockSegments;
  llvm::SmallVector<Operation*, 8> currentSegment;
  
  // First pass: segment operations based on control flow boundaries
  for (Operation &op : mlirBlock->getOperations()) {
    if (isa<tor::YieldOp>(&op) || isa<mlir::func::ReturnOp>(&op) || isa<tor::ReturnOp>(&op)) {
      continue; // Skip terminator operations
    }

    // Check if this operation is a control flow boundary
    if (isa<tor::ForOp>(&op) || isa<tor::IfOp>(&op) || isa<tor::WhileOp>(&op)) {
      llvm::dbgs() << "[BlockHandler] Found control flow op: " << op.getName() << ", currentSegment has "
                   << currentSegment.size() << " ops\n";
      // End current segment if not empty (operations BEFORE control flow)
      if (!currentSegment.empty()) {
        blockSegments.push_back(std::move(currentSegment));
        currentSegment.clear();
        llvm::dbgs() << "[BlockHandler] Created segment for ops before control flow\n";
      }
      // Control flow operations get their own segment
      llvm::SmallVector<Operation*, 8> controlFlowSegment;
      controlFlowSegment.push_back(&op);
      blockSegments.push_back(std::move(controlFlowSegment));
      llvm::dbgs() << "[BlockHandler] Created segment for control flow op\n";
      // Start new segment for operations AFTER control flow
      // (currentSegment is already empty)
    } else {
      // Regular operation - add to current segment
      currentSegment.push_back(&op);
    }
  }

  llvm::dbgs() << "[BlockHandler] After loop: currentSegment has " << currentSegment.size() << " ops\n";
  
  // Add final segment if not empty
  if (!currentSegment.empty()) {
    blockSegments.push_back(std::move(currentSegment));
    llvm::dbgs() << "[BlockHandler] Created final segment for ops after control flow\n";
  }

  llvm::dbgs() << "[BlockHandler] Total segments created: " << blockSegments.size() << "\n";

  // If no segments found, treat entire block as single block
  if (blockSegments.empty()) {
    std::string blockName = generateBlockName(blockId, BlockType::REGULAR);
    BlockInfo block(blockId, blockName, mlirBlock, BlockType::REGULAR);
    blocks.push_back(std::move(block));
    blockMap[blockId] = &blocks.back();
    mlirBlockMap[mlirBlock] = &blocks.back();
    blockId++;
    return success();
  }

  // Create BlockInfo for each segment with proper FIFO propagation
  for (size_t segIdx = 0; segIdx < blockSegments.size(); ++segIdx) {
    auto &segment = blockSegments[segIdx];
    if (segment.empty()) continue;

    // Determine block type based on first operation
    BlockType type = BlockType::REGULAR;
    Operation *firstOp = segment.front();

    if (isa<tor::ForOp>(firstOp)) {
      type = BlockType::LOOP_HEADER;
    } else if (isa<tor::IfOp>(firstOp)) {
      type = BlockType::CONDITIONAL_THEN;
    } else if (isa<tor::WhileOp>(firstOp)) {
      type = BlockType::LOOP_HEADER;
    }

    // Generate hierarchical block name
    std::string blockName = generateBlockName(blockId, type);
    BlockInfo block(blockId, blockName, mlirBlock, type);

    // Store the operations belonging to this segment
    for (Operation *op : segment) {
      block.operations.push_back(op);
    }

    // Analyze all operations in this segment first to populate block's operations
    for (Operation *op : segment) {
      analyzeOperationInBlock(op, block);
    }

    // Propagate input FIFOs only if the value is actually used in this segment
    // Per Blockgen.md: only pass input FIFOs that are consumed by this segment
    for (const auto &pair : input_fifos) {
        Value value = pair.first;
        Instance *fifo = pair.second;

        // Check if this value is actually used in this segment
        if (isValueUsedInBlock(value, block)) {
            block.input_fifos[value] = fifo;
            llvm::dbgs() << "[BlockHandler] Segment " << blockId << " uses input value, adding to input_fifos\n";
        } else {
            llvm::dbgs() << "[BlockHandler] Segment " << blockId << " does NOT use input value, skipping\n";
        }
    }

    // Propagate output FIFOs (these are for values this segment may produce)
    // Only copy the FIFOs that are actually for this block's consumers
    for (const auto &[value, fifoList] : output_fifos) {
        for (const auto &[consumerBlock, fifo] : fifoList) {
            // Add this FIFO to the block's output_fifos
            block.output_fifos[value].push_back(std::make_pair(consumerBlock, fifo));
        }
    }

    // Mark special block types
    if (type == BlockType::LOOP_HEADER) {
      block.is_loop_block = true;

      // For loop headers, track loop results
      if (auto forOp = dyn_cast<tor::ForOp>(segment.front())) {
        for (Value result : forOp.getResults()) {
          block.producedValues.push_back(result);
        }
      }
    }

    blocks.push_back(std::move(block));
    blockMap[blockId] = &blocks.back();
    mlirBlockMap[mlirBlock] = &blocks.back();
    blockId++;
  }

  return success();
}

LogicalResult BlockHandler::processBlock(BlockInfo& block) {
  // Process block following Blockgen.md requirements
  // PANIC: Ensure block has required FIFOs before processing

  // Check critical preconditions
  if (block.blockId >= blocks.size()) {
    llvm::report_fatal_error("Block ID out of range");
  }

  // PANIC: Ensure block type consistency
  if (block.is_loop_block && block.type != BlockType::LOOP_HEADER) {
    llvm::report_fatal_error("Block marked as loop but type is not LOOP_HEADER");
  }

  // Check if this is a loop block and handle it with LoopHandler
  if (block.is_loop_block || block.type == BlockType::LOOP_HEADER) {
    // Token FIFOs may be nullptr for top-level blocks (handled gracefully in LoopHandler)
    llvm::dbgs() << "[BlockHandler] Processing loop block with token FIFOs: "
                 << "input=" << (block.input_token_fifo ? "present" : "null")
                 << ", output=" << (block.output_token_fifo ? "present" : "null") << "\n";

    // Create a LoopHandler to process this loop block with proper FIFO arguments
    // Pass block's name with trailing "_" as prefix for nested components
    std::string loopPrefix = block.blockName + "_";
    LoopHandler loopHandler(pass, mainModule, funcOp, poolInstance,
                           roccInstance, hellaMemInstance, dmaItfc, circuit,
                           mainClk, mainRst, opcode, regRdInstance,
                           block.input_token_fifo, block.output_token_fifo,
                           block.input_fifos, block.output_fifos, loopPrefix);

    // Process the loop block with the LoopHandler
    if (failed(loopHandler.processLoopBlock(block))) {
      return failure();
    }

    return success();
  }

  if (block.is_conditional_block || block.type == BlockType::CONDITIONAL_THEN ||
      block.type == BlockType::CONDITIONAL_ELSE) {
    // Token FIFOs may be nullptr for top-level blocks (handled gracefully in handlers)
    llvm::dbgs() << "[BlockHandler] Processing conditional block with token FIFOs: "
                 << "input=" << (block.input_token_fifo ? "present" : "null")
                 << ", output=" << (block.output_token_fifo ? "present" : "null") << "\n";

    // TODO: Create ConditionalHandler for conditional blocks
    return processRegularBlockWithBBHandler(block);
  }

  // Regular block - Token FIFOs may be nullptr for top-level blocks (handled gracefully in BBHandler)
  llvm::dbgs() << "[BlockHandler] Processing regular block with token FIFOs: "
               << "input=" << (block.input_token_fifo ? "present" : "null")
               << ", output=" << (block.output_token_fifo ? "present" : "null") << "\n";

  return processRegularBlockWithBBHandler(block);
}

LogicalResult BlockHandler::createProducerFIFOs() {
  // Create producer FIFOs for cross-block data communication
  // Following Blockgen.md: fifo_b{i}_b{j}_{op} naming convention
  // PANIC: Ensure critical data structures are valid

  if (crossBlockFlows.empty()) {
    return success(); // No flows to process
  }

  // Counter per (producer, consumer) pair to ensure unique FIFO names for each def-use relationship
  llvm::DenseMap<std::pair<unsigned, unsigned>, unsigned> fifoCounterPerPair;

  for (CrossBlockValueFlow &flow : crossBlockFlows) {
    // PANIC: Ensure flow has valid producer and consumer blocks
    if (!flow.producer_block || !flow.consumer_block) {
      llvm::report_fatal_error("Cross-block flow has null producer or consumer block");
    }

    BlockInfo *producerBlock = flow.producer_block;
    BlockInfo *consumerBlock = flow.consumer_block;
    Value value = flow.value;

    // Skip constants - they don't need FIFOs since there will be no readers
    if (value.getDefiningOp<arith::ConstantOp>()) {
      llvm::dbgs() << "[BlockHandler] Skipping FIFO creation for constant value\n";
      continue;
    }

    // PANIC: Ensure producer block exists in our block list
    if (producerBlock->blockId >= blocks.size()) {
      llvm::report_fatal_error("Producer block ID out of range");
    }

    // Get and increment counter for this (producer, consumer) pair
    auto blockPair = std::make_pair(producerBlock->blockId, consumerBlock->blockId);
    unsigned counter = fifoCounterPerPair[blockPair]++;

    // Producer creates FIFO for this value with def-use naming (producer -> consumer)
    Instance* fifo = createProducerFIFO(value, producerBlock->blockId, consumerBlock->blockId, counter);

    // PANIC: Ensure FIFO creation succeeded
    if (!fifo) {
      llvm::report_fatal_error("Failed to create producer FIFO");
    }

    // Store in producer's output_fifos as (consumer_block, FIFO) pair
    // This allows producer to enqueue to all consumer FIFOs
    producerBlock->output_fifos[value].push_back(std::make_pair(consumerBlock, fifo));

    // Store in THIS specific consumer's input FIFOs (not all consumers!)
    // Each consumer gets its own dedicated FIFO from the producer
    consumerBlock->input_fifos[value] = fifo;

    flow.fifo = fifo;
  }

  return success();
}

Instance* BlockHandler::createProducerFIFO(Value value, unsigned producerBlockId, unsigned consumerBlockId, unsigned counter) {
  auto &builder = mainModule->getBuilder();
  auto savedIP = builder.saveInsertionPoint();

  // Get bit width for FIFO sizing
  unsigned bitWidth = getBitWidth(value.getType());

  // Create FIFO module
  auto *fifoMod = STLLibrary::createFIFO1PushModule(bitWidth, circuit);
  builder.restoreInsertionPoint(savedIP);

  // Create FIFO instance with unique name reflecting def-use relationship
  // Format: {prefix}fifo_b{producer}_b{consumer}_v{counter}
  std::string fifoName = namePrefix + "fifo_b" + std::to_string(producerBlockId) +
                         "_b" + std::to_string(consumerBlockId) +
                         "_v" + std::to_string(counter);
  auto *fifoInstance = mainModule->addInstance(fifoName, fifoMod,
                                               {mainClk.getValue(), mainRst.getValue()});

  return fifoInstance;
}

llvm::SmallVector<BlockInfo*> BlockHandler::findValueConsumers(Value value) {
  llvm::SmallVector<BlockInfo*> consumers;

  llvm::errs() << "\n=== findValueConsumers ===\n";
  if (auto *defOp = value.getDefiningOp()) {
    llvm::errs() << "Finding consumers for value from: " << defOp->getName() << "\n";
  } else {
    llvm::errs() << "Finding consumers for block argument\n";
  }

  for (BlockInfo &block : blocks) {
    if (isValueUsedInBlock(value, block)) {
      consumers.push_back(&block);
    }
  }

  llvm::errs() << "Found " << consumers.size() << " consumer blocks\n";
  return consumers;
}

bool BlockHandler::isValueUsedInBlock(Value value, BlockInfo& targetBlock) {
  // Check if value is used in any operation in this block's segment
  for (Operation *user : value.getUsers()) {
    // Direct use: user is directly in this block's operation list
    for (Operation *blockOp : targetBlock.operations) {
      if (user == blockOp) {
        llvm::errs() << "    ✓ MATCH (direct in segment)\n";
        return true;
      }
    }

    // Nested use: user is inside a control flow operation that belongs to this block's segment
    for (Operation *blockOp : targetBlock.operations) {
      // Check if user is nested within blockOp's regions (handles arbitrary nesting depth)
      if (blockOp->isAncestor(user)) {
        llvm::errs() << "    ✓ MATCH (nested in segment)\n";
        return true;
      }
    }
  }

  llvm::errs() << "  ✗ NO MATCH\n";
  return false;
}

bool BlockHandler::isVirtualValue(Value value) {
  // Check if this value comes from a virtual operation that doesn't need FIFO
  if (auto *defOp = value.getDefiningOp()) {
    // Virtual operations that don't represent actual data flow
    if (isa<memref::GetGlobalOp>(defOp)) {
      return true;
    }

    // Constants are also virtual
    if (isa<arith::ConstantOp>(defOp)) {
      return true;
    }

    // Memory allocation operations are virtual
    if (isa<memref::AllocOp, memref::AllocaOp>(defOp)) {
      return true;
    }

    // Special handling for interface/SPM operations - don't track their tokens as cross-block values
    if (isa<aps::ItfcBurstLoadReq, aps::ItfcBurstStoreReq, aps::ItfcLoadReq, aps::ItfcStoreReq, aps::SpmLoadReq>(defOp)) {
      // Don't track the request token as a produced value - it should only be consumed locally
      return true;
    }

    // Special handling for interface collect operations - they don't produce values for cross-block flow
    if (isa<aps::ItfcBurstLoadCollect, aps::ItfcBurstStoreCollect>(defOp)) {
      // Collect operations don't produce values that flow to other blocks
      return true;
    }
  }

  return false;
}

std::string BlockHandler::getFIFOName(StringRef prefix, unsigned blockId, StringRef suffix) {
  return std::string(prefix) + "_b" + std::to_string(blockId) + 
         (suffix.empty() ? "" : "_" + std::string(suffix));
}

unsigned BlockHandler::getBitWidth(mlir::Type type) {
  if (auto intType = dyn_cast<mlir::IntegerType>(type)) {
    return intType.getWidth();
  }
  // Default to 32 bits for unknown types
  return 32;
}

LogicalResult BlockHandler::processAllBlocks() {
  llvm::dbgs() << "[BlockHandler] Processing all blocks through specialized handlers\n";

  // Update token and input FIFOs for sub-blocks based on distribution
  for (unsigned i = 0; i < blocks.size(); i++) {
    BlockInfo &block = blocks[i];

    // === 1. Determine input token FIFO for this sub-block ===
    if (i == 0) {
      // First sub-block receives token from distribution rule (if exists) or parent
      if (needsInputDistribution) {
        // Distribution rule consumes parent's inputTokenFIFO
        // Distribution rule enqueues to input_distribution_token_fifo
        // First sub-block dequeues from input_distribution_token_fifo
        block.input_token_fifo = input_distribution_token_fifo;
        llvm::dbgs() << "[BlockHandler] First sub-block uses distribution token FIFO\n";
      } else {
        // No distribution needed - first sub-block directly uses parent's inputTokenFIFO
        block.input_token_fifo = inputTokenFIFO;
        llvm::dbgs() << "[BlockHandler] First sub-block uses parent input token FIFO\n";
      }
    } else {
      // Subsequent sub-blocks receive token from previous sub-block
      block.input_token_fifo = blocks[i-1].output_token_fifo;
      llvm::dbgs() << "[BlockHandler] Sub-block " << i
                   << " uses previous sub-block's output token FIFO\n";
    }

    // === 2. Determine output token FIFO for this sub-block ===
    if (i == blocks.size() - 1) {
      // Last sub-block enqueues to parent's outputTokenFIFO
      block.output_token_fifo = outputTokenFIFO;
    }
    // Note: For non-last sub-blocks, output_token_fifo is created in createBlockTokenFIFOs

    // === 3. Determine input value FIFOs for this sub-block ===
    if (i == 0 && needsInputDistribution) {
      // First sub-block with distribution: use distribution FIFOs
      // Only include values that THIS sub-block actually uses
      block.input_fifos.clear();
      for (auto &[inputValue, subBlockMap] : input_distribution_fifos) {
        if (subBlockMap.count(i)) {
          block.input_fifos[inputValue] = subBlockMap[i];
          llvm::dbgs() << "[BlockHandler] First sub-block uses distribution FIFO for value\n";
        }
      }
    } else if (i == 0 && !needsInputDistribution) {
      // First sub-block without distribution: use parent's input_fifos directly
      block.input_fifos = input_fifos;
      llvm::dbgs() << "[BlockHandler] First sub-block uses parent input FIFOs directly\n";
    } else if (i > 0 && needsInputDistribution) {
      // Subsequent sub-blocks with distribution: use distribution FIFOs (if they need the values)
      // Also use cross-block FIFOs created by analyzeCrossBlockDataflow
      for (auto &[inputValue, subBlockMap] : input_distribution_fifos) {
        if (subBlockMap.count(i)) {
          block.input_fifos[inputValue] = subBlockMap[i];
          llvm::dbgs() << "[BlockHandler] Sub-block " << i
                       << " uses distribution FIFO for value\n";
        }
      }
    }
    // Note: cross-block FIFOs between sub-blocks are already populated by analyzeCrossBlockDataflow

    // === 4. Determine output value FIFOs for this sub-block ===
    if (i == blocks.size() - 1) {
      // Last sub-block: use parent's output_fifos for values needed by parent's consumers
      block.output_fifos = output_fifos;
    }
    // Note: For non-last sub-blocks, output_fifos are created in createProducerFIFOs
  }

  // Process each block using appropriate handler
  for (BlockInfo &block : blocks) {
    if (failed(processBlock(block))) {
      return failure();
    }
  }

  return success();
}

LogicalResult BlockHandler::processRegularBlockWithBBHandler(BlockInfo& block) {
  // Process regular block using BBHandler with proper FIFO argument handling
  // Following Blockgen.md: input_fifos and output_fifos are passed as arguments

  BBHandler bbHandler(pass, mainModule, funcOp, poolInstance, roccInstance,
                     hellaMemInstance, regRdInstance, dmaItfc, circuit, mainClk, mainRst,
                     opcode);

  // Use the new BlockInfo interface for cleaner API and proper blockName access
  return bbHandler.processBasicBlock(block);
}


void BlockHandler::analyzeOperationInBlock(Operation *op, BlockInfo &block) {
  // Analyze operation within a block following Blockgen.md requirements
  // Track timing, produced values, and consumed values for data dependency analysis

  // Skip tor.timegraph operations - they are metadata and shouldn't affect block timing
  if (isa<tor::TimeGraphOp>(op)) {
    return;
  }

  // Track timing
  if (auto startAttr = op->getAttrOfType<IntegerAttr>("starttime")) {
    int64_t startTime = startAttr.getInt();
    if (block.startTime == -1 || startTime < block.startTime) {
      block.startTime = startTime;
    }
  }

  if (auto endAttr = op->getAttrOfType<IntegerAttr>("endtime")) {
    int64_t endTime = endAttr.getInt();
    if (endTime > block.endTime) {
      block.endTime = endTime;
    }
  }

  // Special handling for interface/SPM request operations - don't track their tokens as cross-block values
  if (isa<aps::ItfcBurstLoadReq, aps::ItfcBurstStoreReq, aps::ItfcLoadReq, aps::ItfcStoreReq, aps::SpmLoadReq>(op)) {
    // Don't track the request token as a produced value - it should only be consumed locally
    return;
  }

  // Special handling for interface collect operations - they don't produce values for cross-block flow
  if (isa<aps::ItfcBurstLoadCollect, aps::ItfcBurstStoreCollect>(op)) {
    // Collect operations don't produce values that flow to other blocks
    return;
  }

  // Track produced values, but skip virtual operations
  if (isa<memref::GetGlobalOp, arith::ConstantOp, memref::AllocOp, memref::AllocaOp>(op)) {
    // Virtual operations don't need cross-block FIFOs
  } else {
    // Track produced values for non-virtual operations
    for (Value result : op->getResults()) {
      block.producedValues.push_back(result);
    }
  }

  // Track consumed values (from other blocks)
  for (Value operand : op->getOperands()) {
    if (auto *defOp = operand.getDefiningOp()) {
      if (defOp->getBlock() != block.mlirBlock) {
        block.consumedValues.push_back(operand);
      }
    } else if (auto blockArg = dyn_cast<BlockArgument>(operand)) {
      if (blockArg.getOwner() != block.mlirBlock) {
        block.consumedValues.push_back(operand);
      }
    }
  }
}

std::string BlockHandler::generateBlockName(unsigned blockId, BlockType type, const std::string& parentName) {
  std::string baseName;

  // Generate base name based on block type
  switch (type) {
    case BlockType::REGULAR:
      baseName = "block_" + std::to_string(blockId);
      break;
    case BlockType::LOOP_HEADER:
      baseName = "loop_" + std::to_string(blockId);
      break;
    case BlockType::CONDITIONAL_THEN:
      baseName = "if_then_" + std::to_string(blockId);
      break;
    case BlockType::CONDITIONAL_ELSE:
      baseName = "if_else_" + std::to_string(blockId);
      break;
    case BlockType::CONDITIONAL_EXIT:
      baseName = "if_exit_" + std::to_string(blockId);
      break;
    default:
      baseName = "block_" + std::to_string(blockId);
      break;
  }

  // If parent name is provided, create hierarchical name
  if (!parentName.empty()) {
    return parentName + baseName;
  }

  // Use namePrefix from constructor (includes opcode)
  return namePrefix + baseName;
}

//===----------------------------------------------------------------------===//
// Input Distribution Implementation (for sub-blocks with shared inputs)
//===----------------------------------------------------------------------===//

LogicalResult BlockHandler::analyzeInputDistributionNeeds() {
  llvm::dbgs() << "[BlockHandler] Analyzing input distribution needs for sub-blocks\n";

  // If we don't have multiple sub-blocks, no distribution needed
  if (blocks.size() <= 1) {
    llvm::dbgs() << "[BlockHandler] Only " << blocks.size() << " sub-block(s), no distribution needed\n";
    needsInputDistribution = false;
    return success();
  }

  // For each value in input_fifos, check which sub-blocks use it
  for (auto &[inputValue, inputFIFO] : input_fifos) {
    if (!inputFIFO)
      continue;

    llvm::SmallVector<unsigned> subBlocksUsingValue;

    // Check each sub-block to see if it uses this input value
    for (unsigned i = 0; i < blocks.size(); i++) {
      BlockInfo &subBlock = blocks[i];
      if (isValueUsedInBlock(inputValue, subBlock)) {
        subBlocksUsingValue.push_back(i);
        llvm::dbgs() << "[BlockHandler] Input value used by sub-block " << i << "\n";
      }
    }

    // AGGRESSIVE: Only need distribution if MULTIPLE sub-blocks use this value
    // If only 0 or 1 sub-block uses it, normal cross-block FIFO is sufficient
    if (subBlocksUsingValue.size() >= 2) {
      needsInputDistribution = true;
      llvm::dbgs() << "[BlockHandler] Input value needs distribution to "
                   << subBlocksUsingValue.size() << " sub-blocks (MULTIPLE consumers)\n";

      // Record which sub-blocks need this value (for later FIFO creation)
      for (unsigned subBlockIdx : subBlocksUsingValue) {
        // Mark this (value, sub-block) pair for FIFO creation
        // Actual FIFO creation happens in createInputDistributionInfrastructure
        input_distribution_fifos[inputValue][subBlockIdx] = nullptr;
      }
    } else if (subBlocksUsingValue.size() == 1) {
      llvm::dbgs() << "[BlockHandler] Input value used by only 1 sub-block, no distribution needed (use normal cross-block FIFO)\n";
    } else {
      llvm::dbgs() << "[BlockHandler] Input value not used by any sub-block\n";
    }
  }

  if (needsInputDistribution) {
    llvm::dbgs() << "[BlockHandler] Input distribution IS needed (some values have multiple consumers)\n";
  } else {
    llvm::dbgs() << "[BlockHandler] Input distribution NOT needed (no values with multiple consumers)\n";
  }

  return success();
}

LogicalResult BlockHandler::createInputDistributionInfrastructure() {
  if (!needsInputDistribution) {
    llvm::dbgs() << "[BlockHandler] No input distribution needed, skipping infrastructure\n";
    return success();
  }

  llvm::dbgs() << "[BlockHandler] Creating input distribution infrastructure\n";

  auto &builder = mainModule->getBuilder();
  auto savedIP = builder.saveInsertionPoint();

  // 1. Create token FIFO: parent -> distribution rule
  auto *tokenFifoMod = STLLibrary::createFIFO1PushModule(1, circuit);
  builder.restoreInsertionPoint(savedIP);
  std::string tokenFifoName = namePrefix + "dist_token_fifo";
  input_distribution_token_fifo = mainModule->addInstance(
      tokenFifoName, tokenFifoMod, {mainClk.getValue(), mainRst.getValue()});
  llvm::dbgs() << "[BlockHandler] Created distribution token FIFO: " << tokenFifoName << "\n";

  // 2. For each input value used by sub-blocks, create distribution FIFOs
  for (auto &[inputValue, subBlockMap] : input_distribution_fifos) {
    for (auto &[subBlockIdx, _] : subBlockMap) {
      // Create dedicated FIFO for this sub-block
      unsigned bitWidth = getBitWidth(inputValue.getType());
      auto *fifoMod = STLLibrary::createFIFO1PushModule(bitWidth, circuit);
      builder.restoreInsertionPoint(savedIP);

      std::string fifoName = namePrefix + "dist_to_block" +
                             std::to_string(subBlockIdx) + "_fifo_v" +
                             std::to_string(input_distribution_fifos[inputValue].size() - 1);

      Instance *distFifo = mainModule->addInstance(
          fifoName, fifoMod, {mainClk.getValue(), mainRst.getValue()});

      input_distribution_fifos[inputValue][subBlockIdx] = distFifo;

      llvm::dbgs() << "[BlockHandler] Created distribution FIFO: " << fifoName
                   << " for sub-block " << subBlockIdx << " (width=" << bitWidth << ")\n";
    }
  }

  return success();
}

LogicalResult BlockHandler::generateInputDistributionRule() {
  if (!needsInputDistribution) {
    llvm::dbgs() << "[BlockHandler] No input distribution rule needed\n";
    return success();
  }

  llvm::dbgs() << "[BlockHandler] Generating input distribution rule\n";

  std::string ruleName = namePrefix + "input_distribution";
  auto *rule = mainModule->addRule(ruleName);

  // === GUARD ===
  // Per CMT2 pattern: always return 1'b1
  // Coordination is handled automatically by FIFO availability (deq/enq operations)
  rule->guard([](mlir::OpBuilder &b) {
    auto loc = b.getUnknownLoc();
    auto alwaysTrue = UInt::constant(1, 1, b, loc);
    b.create<circt::cmt2::ReturnOp>(loc, mlir::ValueRange{alwaysTrue.getValue()});
  });

  // === BODY ===
  rule->body([&](mlir::OpBuilder &b) {
    auto loc = b.getUnknownLoc();

    llvm::dbgs() << "[BlockHandler] Generating distribution rule body\n";

    // 1. Dequeue input token from parent
    if (inputTokenFIFO) {
      inputTokenFIFO->callMethod("deq", {}, b);
      llvm::dbgs() << "[BlockHandler] Distribution rule: dequeued input token\n";
    }

    // 2. For each input value, dequeue once and distribute to all sub-blocks
    for (auto &[inputValue, subBlockMap] : input_distribution_fifos) {
      auto inputFifoIt = input_fifos.find(inputValue);
      if (inputFifoIt == input_fifos.end() || !inputFifoIt->second)
        continue;

      Instance *inputFIFO = inputFifoIt->second;

      // Dequeue ONCE from input FIFO
      auto dequeuedValue = inputFIFO->callMethod("deq", {}, b)[0];
      llvm::dbgs() << "[BlockHandler] Distribution rule: dequeued input value\n";

      // Enqueue to ALL sub-block distribution FIFOs that need it
      for (auto &[subBlockIdx, distFifo] : subBlockMap) {
        if (distFifo) {
          distFifo->callMethod("enq", {dequeuedValue}, b);
          llvm::dbgs() << "[BlockHandler] Distribution rule: enqueued to sub-block "
                       << subBlockIdx << " FIFO\n";
        }
      }
    }

    // 3. Enqueue token to distribution token FIFO (signals distribution complete)
    if (input_distribution_token_fifo) {
      auto tokenVal = UInt::constant(1, 1, b, loc);
      input_distribution_token_fifo->callMethod("enq", {tokenVal.getValue()}, b);
      llvm::dbgs() << "[BlockHandler] Distribution rule: enqueued distribution token\n";
    }

    b.create<circt::cmt2::ReturnOp>(loc, mlir::ValueRange{});
  });

  rule->finalize();

  llvm::dbgs() << "[BlockHandler] Input distribution rule generated: " << ruleName << "\n";

  return success();
}

} // namespace mlir