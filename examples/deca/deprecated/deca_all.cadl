// DECA Decompression - Auto Unroll Version
// Uses [[unroll]] directive for cleaner code

// ============================================================================
// Memory Buffers
// ============================================================================

static values: [i64; 8];

#[partition_dim_array([0])]
#[partition_factor_array([4])]
#[partition_cyclic_array([1])]
static dense_values: [i8; 32];

#[partition_dim_array([0])]
#[partition_factor_array([4])]
#[partition_cyclic_array([1])]
static decompressed_weights: [i16; 32];

static vidx: u32 = 0;

// ============================================================================
// DECA Decompression - Auto Unroll Version
// ============================================================================

#[opcode(7'b0001011)]
#[funct7(7'b0000101)]
rtype deca_decompress_u1(rs1: u5, rs2: u5, rd: u5) {
    let base_addr: u32 = _irf[rs1];
    let out_addr: u32 = _irf[rs2];
    vidx = 0;

    // Burst read compressed data
    values[0 +: ] = _burst_read[base_addr +: 8];
    let bitmask: u32 = _mem[base_addr + 64];
    let global_scale: i16 = _mem[base_addr + 68];

    // ========================================================================
    // Stage 1: Sparse-to-Dense Expansion (Auto Unroll Version)
    // Process all 32 elements in a single loop with [[unroll]] directive
    // ========================================================================

    [[unroll(32)]]
    with idx: u32 = (0, idx_) do {
        // Calculate which byte and bit in the bitmask
        let byte_idx: u32 = idx >> 3;  // idx / 8
        let bit_in_byte: u32 = idx & 7;  // idx % 8

        // Extract the corresponding byte from bitmask
        let mask_byte: u8 = sel {
            byte_idx == 0: bitmask[7:0],
            byte_idx == 1: bitmask[15:8],
            byte_idx == 2: bitmask[23:16],
            byte_idx == 3: bitmask[31:24],
        };

        // Check if this element is non-zero
        let is_nonzero: u1 = (mask_byte >> bit_in_byte)[0:0];

        // Read from sparse values if non-zero
        let zero_i8: i8 = 0;
        let value_idx: u32 = vidx >> 3;  // vidx / 8
        let value_offset: u32 = vidx & 7;  // vidx % 8

        let val_double_word: i64 = values[value_idx];
        let val: i8 = (val_double_word >> (value_offset * 8))[7:0];

        // Write to dense array
        dense_values[idx] = if is_nonzero { val } else { zero_i8 };

        // Update sparse index (increment if this was non-zero)
        vidx = vidx + (if is_nonzero {1} else {0});

        let idx_: u32 = idx + 1;
    } while (idx_ < 32);

    // ========================================================================
    // Stage 2: Fully Affine Decompression
    // ========================================================================
    [[unroll(4)]]
    with idx: u32 = (0, idx_) do {
        let val: i8 = dense_values[idx];

        let val32: i32 = val;
        let global_scale32: i32 = global_scale;
        let mul_result: i32 = val32 * global_scale32;
        let dequant: i16 = (mul_result >> 8)[15:0];

        decompressed_weights[idx] = dequant;
        let idx_: u32 = idx + 1;
    } while (idx_ < 32);

    // Burst write decompressed output
    _burst_write[out_addr +: 64] = decompressed_weights[0 +: ];
    _irf[rd] = 0;
}

// GEMM - General Matrix Multiply
// Computes matrix-matrix product: C = A × B
// Formula: C[m×p] = A[m×n] × B[n×p]
// This implementation uses tiling for efficiency and hardware resource optimization
//
// Configuration:
// - M = 4 (rows of A and C)
// - N = 4 (columns of A, rows of B)
// - P = 4 (columns of B and C)
// - All matrices use i32 fixed-point representation

// ============================================================================
// Memory Buffers - All arrays are partitioned for parallel access
// ============================================================================

// Matrix A storage (M × N = 4 × 4 = 16 elements)
// Complete cyclic partitioning for parallel row access
#[partition_dim_array([0])]
#[partition_factor_array([4])]
#[partition_cyclic_array([1])]
static matrix_a: [i32; 16];

// Matrix B storage (N × P = 4 × 4 = 16 elements)
// Complete cyclic partitioning for parallel column access
#[partition_dim_array([0])]
#[partition_factor_array([4])]
#[partition_cyclic_array([1])]
static matrix_b: [i32; 16];

// Matrix C storage (M × P = 4 × 4 = 16 elements) - output matrix
// Complete cyclic partitioning for parallel write access
#[partition_dim_array([0])]
#[partition_factor_array([4])]
#[partition_cyclic_array([1])]
static matrix_c: [i32; 16];

// Accumulator for dot product computation
static acc: i32;

// ============================================================================
// GEMM Kernel - Matrix-Matrix Multiplication
// ============================================================================

#[opcode(7'b0101011)]
#[funct7(7'b0111000)]
rtype gemm_4x4(rs1: u5, rs2: u5, rd: u5) {
    // rs1 points to base address for matrix A and B data
    // rs2 points to output address for matrix C
    // rd receives status (0 = success)

    let addr_a: u32 = _irf[rs1];       // Base address of matrix A
    // let addr_b: u32 = _irf[rs1] + 64;  // Matrix B follows A (16 words × 4 bytes = 64 bytes)
    let out_addr: u32 = _irf[rs2];     // Output address for matrix C

    // ========================================================================
    // Stage 1: Burst Read Input Matrices
    // ========================================================================

    // Burst read matrix A (16 i32 elements = 64 bytes)
    matrix_a[0 +: ] = _burst_read[addr_a +: 16];

    // Burst read matrix B (16 i32 elements = 64 bytes)
    matrix_b[0 +: ] = _burst_read[addr_a + 64 +: 16];

    // ========================================================================
    // Stage 2: Matrix Multiplication - Triple Nested Loop
    // Compute C[i,j] = Σₖ A[i,k] × B[k,j]
    // ========================================================================

    // Outer loop: iterate over rows of A (and C)
    with i: u32 = (0, i_) do {

        // Middle loop: iterate over columns of B (and C)
        [[unroll(4)]]
        with j: u32 = (0, j_) do {
            // Reset accumulator for each output element
            acc = 0;

            // Inner loop: dot product over dimension N
            [[unroll(4)]]
            with k: u32 = (0, k_) do {
                // Access A[i,k]: row-major layout → index = i*N + k
                let a_idx: u32 = i * 4 + k;
                let a_val: i32 = matrix_a[a_idx];

                // Access B[k,j]: row-major layout → index = k*P + j
                let b_idx: u32 = k * 4 + j;
                let b_val: i32 = matrix_b[b_idx];

                // Multiply-accumulate: acc += A[i,k] × B[k,j]
                acc = acc + a_val * b_val;

                let k_: u32 = k + 1;
            } while (k_ < 4);

            // Store accumulated result to C[i,j]
            let c_idx: u32 = i * 4 + j;
            matrix_c[c_idx] = acc;

            let j_: u32 = j + 1;
        } while (j_ < 4);

        let i_: u32 = i + 1;
    } while (i_ < 4);

    // ========================================================================
    // Stage 3: Burst Write Output Matrix
    // ========================================================================

    // Burst write matrix C (16 i32 elements = 64 bytes)
    _burst_write[out_addr +: 16] = matrix_c[0 +: ];

    // Return success status
    _irf[rd] = 0;
}
